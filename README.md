# Задание 2: Работа со строками
# Вариант 6
## "Создайте рекурсивную функцию для подсчета количества гласных букв в строке"
## Как работает алгоритм
Функция в python  ```count_vowels(s)``` сначала проверяет базовый случай ```if not s```:, и если строка пуста, возвращает ```0```. Иначе берётся первый символ ```first_char = s[0]``` и остаток строки ```rest = s[1:]```. Если ```first_char.lower() in 'aeiou'```, то возвращается ```1 + count_vowels(rest)```, иначе — ```count_vowels(rest)```. 

В C++ версии функция ```count_vowels(const string& s, int index = 0)``` проверяет условие ```if (index >= s.length())```, и при его истинности возвращает ```0```. Затем текущий символ присваивается как ```char current = s[index]```, и проверяется выражение ```bool is_vowel = (current == 'a' || current == 'e' || current == 'i' || current == 'o' || current == 'u' || current == 'A' || current == 'E' || current == 'I' || current == 'O' || current == 'U')```;. После этого возвращается ```(is_vowel ? 1 : 0) + count_vowels(s, index + 1)```. 

В Java версии метод ```countVowels(String s, int index)``` сначала проверяет ```if (index >= s.length())```, и если условие выполняется, возвращает ```0```. Далее извлекается символ ```char current = s.charAt(index)```, и проверяется ```boolean isVowel = "aeiouAEIOU".indexOf(current) != -1;```. Затем возвращается ```(isVowel ? 1 : 0) + countVowels(s, index + 1)```, а для удобства вызова предусмотрен упрощённый метод ```countVowels(String s)```, который вызывает ```return countVowels(s, 0);```. 

Во всех трёх реализациях рекурсия последовательно обрабатывает каждый символ строки ровно один раз и завершается при достижении конца строки, накапливая итоговое количество гласных через возврат значений на каждом шаге.
## На выходе в каждом коде получается: "3"
## Временная сложность
O(n)
## Почему именно такая сложность?
Каждый символ обрабатывается ровно один раз (один рекурсивный вызов на символ). Глубина рекурсии — n, но работа на каждом уровне — O(1).
# Контрольный вопрос № 4
Мемоизация - это техника оптимизации, при которой результаты выполнения функции для заданных входных параметров сохраняются («кэшируются») при первом вычислении, а при последующих вызовах с теми же аргументами вместо повторного выполнения функции возвращается сохранённый результат. В рекурсивных алгоритмах мемоизация помогает избежать многократного вычисления одних и тех же подзадач, которые часто возникают из-за перекрывающихся ветвей рекурсии. Например, в наивной рекурсивной реализации вычисления чисел Фибоначчи ```fib(n)``` вызывает ```fib(n-1)``` и ```fib(n-2)```, а каждый из них, в свою очередь, снова вызывает одни и те же более мелкие значения, что приводит к экспоненциальному росту числа вызовов. Если сохранять уже вычисленные значения ```fib(k)``` в словаре или массиве, то каждое значение будет посчитано лишь один раз, и общая сложность алгоритма снизится с экспоненциальной до линейной. Таким образом, мемоизация значительно повышает эффективность рекурсивных алгоритмов с перекрывающимися подзадачами, превращая их в решения, близкие к динамическому программированию.
