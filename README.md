# **Аналитическая работа по алгоритмическим структурам сортировки и поиска на языках: C++, Python, Java. (Виговская Катя, УИБО-10-24)**
## 1. Алгоритм сортировки выбором (Selection Sort)

### Определение:
Сортировка выбором (Selection Sort) — это алгоритм, который последовательно находит минимальные элементы массива и помещает их на правильное место. Таким образом, каждый проход алгоритма гарантирует размещение хотя бы одного элемента на своем месте.

### Анализ:
Алгоритм состоит из двух вложенных циклов:
- Первый цикл выполняется ```N−1``` раз (N — длина массива).
- Второй внутренний цикл также выполняется порядка ```O(N)``` операций на каждом этапе.
##### На выходе получается: "Исходный массив: 64 25 12 22 11 Отсортированный массив: 11 12 22 25 64"

### Временная сложность:
 ```O(n²)```.

### Почему именно так?
Даже если массив уже частично отсортирован, алгоритм всё равно вынужден пройти по всей области слева направо, сравнивая все оставшиеся элементы друг с другом.
Каждый раз нам приходится искать новый минимум, даже если он очевиден визуально.
Это означает, что количество сравнений и перемещений остаётся постоянным независимо от начального состояния массива.

## 2. Алгоритм сортировки пузырьком («Bubble Sort») 

### Определение:
Алгоритм "Bubble Sort" основывается на последовательном сравнении пар соседних элементов и их обмене местами, если порядок нарушен. Процесс повторяется многократно, пока массив не станет упорядоченным.

### Анализ:
- Внешний цикл: Перебирается весь массив за исключением последних уже отсортированных элементов ```(i)```.
- Внутренний цикл: Происходит сравнение каждого текущего элемента ```j``` с последующим элементом ```j+1```. Если текущий элемент больше последующего, они меняются местами.
- Флаг свопа: Используется для оптимизации, если на какой-то итерации не произошло ни одной перестановки, значит массив уже отсортирован, и внешний цикл прерывается раньше.
- Обмен значений: Для изменения позиций используется вспомогательная переменная, в которой временно сохраняется одно из значений.
##### На выходе получилось: "Исходный массив: [64, 34, 25, 12, 22, 11] Отсортированный массив: [11, 12, 22, 25, 34, 64]"
### Временная сложность:
 ```O(n²)```.

### Почему именно так?
- Лучший случай: ```O(n)```, так как достаточно одного прохода для проверки отсутствия необходимых перестановок.
- Средний и худший случаи: каждое сравнение занимает линейное время относительно длины массива, а число таких сравнений растёт пропорционально квадрату числа элементов.

## 3. Алгоритм cортировки вставками (Insertion Sort)
### Определение:
Алгоритм сортировки вставками (Insertion Sort) — простой алгоритм сортировки, работающий аналогично процессу упорядочивания карт вручную. Его идея заключается в последовательном переносе каждого элемента на нужную позицию среди ранее отсортированных элементов.

## 4. Алгоритм сортировки слиянием (Merge Sort)
### Определение:
Сортировка слиянием (Merge Sort) — это алгоритм «разделяй и властвуй», который рекурсивно разделяет массив на две половины, сортирует каждую половину, а затем объединяет отсортированные половины в один отсортированный массив.
### Анализ:
#### На выходе получилось: "Исходный массив: 12 11 13 5 6 7 Отсортированный массив: 5 6 7 11 12 13"
### Временная сложность:
- Лучший случай: ```O(n log n)```
- Средний и худший случаи: ```O(n log n)```
### Почему именно так?
Алгоритм всегда делит массив пополам (log n уровней) и на каждом уровне выполняет слияние за ```O(n)```. Отсюда сложность ```O(n log n)``` во всех случаях.
## 5. Алгоритм сортировки Шелла (Shell Sort)
### Определение:
### Анализ:
#### На выходе получилось:
### Временная сложность:
### Почему именно так?
## 6. Алгоритм быстрой сортировки (Quick Sort)
### Определение:
### Анализ:
#### На выходе получилось:
### Временная сложность:
### Почему именно так?
## 7. Алгоритм пирамидальной сортировки (Heap Sort)
### Определение:
### Анализ:
#### На выходе получилось:
### Временная сложность:
### Почему именно так?
## 8. Алгоритм последовательного (линейный) поиска (Linear Search)
### Определение:
### Анализ:
#### На выходе получилось:
### Временная сложность:
### Почему именно так?
## 9. Алгоритм бинарного поиска (Binary Search)
### Определение:
### Анализ:
#### На выходе получилось:
### Временная сложность:
### Почему именно так?
## 10. Алгоритм интерполирующего поиска (Interpolation Search)
### Определение:
### Анализ:
#### На выходе получилось:
### Временная сложность:
### Почему именно так?
## 11. Алгоритм поиска по Фибоначчи (Fibonacci Search)
### Определение:
### Анализ:
#### На выходе получилось:
### Временная сложность:
### Почему именно так?

