# Задание 2: Работа со строками (Виговска, УИБО-10-24)
# Вариант 6
## "Создайте рекурсивную функцию для подсчета количества гласных букв в строке"
## Как работает алгоритм

**Java код**


Рекурсивная функция `countVowels` использует параметр `index` для отслеживания текущей позиции в строке. Функция `charAt(index)` извлекает текущий символ, затем функция `indexOf(current)` проверяет наличие символа в строке-маске гласных "aeiouAEIOU". Если символ найден (возвращаемое значение ≠ -1), переменная `isVowel` становится true. Тернарный оператор `(isVowel ? 1 : 0)` преобразует boolean в числовое значение. Рекурсивный вызов `countVowels(s, index + 1)` перемещает обработку к следующему символу. Перегруженная функция `countVowels(String s)` обеспечивает удобный интерфейс, инициируя рекурсию с начальным индексом 0. Базовый случай срабатывает когда `index >= s.length()`, возвращая 0 и завершая рекурсию.

**C++ код**


Рекурсивная функция `count_vowels` использует параметр по умолчанию `index = 0` для удобства вызова. Функция `s.length()` определяет границы строки, а оператор `[]` (s[index]) обеспечивает доступ к символам. Проверка гласных выполняется через серию сравнений с логическими операторами `||`, которые объединяют условия. Переменная `is_vowel` становится true если любой из операторов сравнения возвращает true. Тернарный оператор `(is_vowel ? 1 : 0)` конвертирует результат в числовое значение. Рекурсивный вызов `count_vowels(s, index + 1)` с инкрементом индекса продвигает обработку строки. В функции `main()`, `cout` и `endl` обеспечивают форматированный вывод результата.

**Python код:**


Рекурсивная функция `count_vowels` использует подход разделения строки на первый символ и остаток. Функция `not s` проверяет базовый случай (пустая строка). Оператор `[0]` извлекает первый символ, а оператор среза `[1:]` создает новую строку без первого символа. Метод `lower()` обеспечивает регистронезависимое сравнение, преобразуя символ к нижнему регистру. Оператор `in` проверяет принадлежность символа строке гласных 'aeiou'. В зависимости от результата проверки, функция возвращает либо `1 + count_vowels(rest)` (если гласная), либо `count_vowels(rest)` (если согласная). Каждый рекурсивный вызов уменьшает длину строки на 1 символ, пока не будет достигнут базовый случай с пустой строкой, возвращающей 0.
Во всех трёх реализациях рекурсия последовательно обрабатывает каждый символ строки ровно один раз и завершается при достижении конца строки, накапливая итоговое количество гласных через возврат значений на каждом шаге.
## На выходе в каждом коде получается: "3"
## Временная сложность
O(n)
## Почему именно такая сложность?
Каждый символ обрабатывается ровно один раз (один рекурсивный вызов на символ). Глубина рекурсии — n, но работа на каждом уровне — O(1).
# Контрольный вопрос № 4
Мемоизация - это техника оптимизации, при которой результаты выполнения функции для заданных входных параметров сохраняются («кэшируются») при первом вычислении, а при последующих вызовах с теми же аргументами вместо повторного выполнения функции возвращается сохранённый результат. В рекурсивных алгоритмах мемоизация помогает избежать многократного вычисления одних и тех же подзадач, которые часто возникают из-за перекрывающихся ветвей рекурсии. Например, в наивной рекурсивной реализации вычисления чисел Фибоначчи ```fib(n)``` вызывает ```fib(n-1)``` и ```fib(n-2)```, а каждый из них, в свою очередь, снова вызывает одни и те же более мелкие значения, что приводит к экспоненциальному росту числа вызовов. Если сохранять уже вычисленные значения ```fib(k)``` в словаре или массиве, то каждое значение будет посчитано лишь один раз, и общая сложность алгоритма снизится с экспоненциальной до линейной. Таким образом, мемоизация значительно повышает эффективность рекурсивных алгоритмов с перекрывающимися подзадачами, превращая их в решения, близкие к динамическому программированию.
