# **Аналитическая работа по алгоритмическим структурам сортировки и поиска на языках: C++, Python, Java. (Виговская Катя, УИБО-10-24)**

## Алгоритмы сортировки

### **1. Анализ алгоритма сортировки выбором**

#### **Определение:**
Сортировка выбором ```(Selection Sort)``` — это алгоритм, который на каждом шаге находит минимальный элемент в неотсортированной части массива и меняет его местами с текущим элементом.

#### **Как работает алгоритм:**
Внешний цикл ```for``` проходит по всем элементам массива. Для каждой позиции ```i``` внутренний цикл for ищет минимальный элемент в оставшейся части массива. Когда находится меньший элемент ```(if (arr[j] < arr[minIndex]))```, запоминается его позиция ```minIndex = j```. После завершения поиска элементы меняются местами через функцию ```swap()```.
#### Сортировка выбором (C++)
Исходный массив:
64 25 12 22 11 
Отсортированный массив:
11 12 22 25 64 

#### **Оценка временной сложности:**
Время - ```O(n²)```

#### **Почему эта временная сложность:**
Временная сложность ```O(n²)``` возникает потому, что выполняется ```n(n-1)/2``` сравнений - для каждого элемента нужно проверить все оставшиеся элементы в неотсортированной части массива.

### **2. Анализ алгоритма сортировки обменом (пузырьком)**

#### **Определение:**
Сортировка обменом (пузырьком) ```(Bubble Sort)``` — алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке.

#### **Как работает алгоритм:**
Используется цикл ```do-while``` с флагом ```swapped```. Внутренний цикл ```for``` проходит по массиву и сравнивает соседние элементы. Если текущий элемент больше следующего ```(if (array[i] > array[i+1]))```, происходит обмен через временную переменную ```temp```. Флаг ```swapped``` устанавливается в ```true``` при каждом обмене. Цикл повторяется до тех пор, пока не будет выполнено полного прохода без обменов.
#### Сортировка пузырьком (Java)
Исходный массив:
64 34 25 12 22 11 90 
Отсортированный массив:
11 12 22 25 34 64 90 

#### **Оценка временной сложности:**
Время - ```O(n²)```

#### **Почему эта временная сложность:**
Временная сложность ```O(n²)``` возникает потому, что в худшем случае требуется ```n-1``` проходов по массиву, и на каждом проходе выполняется ```n-i``` сравнений, что в сумме дает ```n(n-1)/2``` операций.

### **3. Анализ алгоритма сортировки вставками**

#### **Определение:**
Сортировка вставками ```(Insertion Sort)``` — алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место в отсортированной части.

#### **Как работает алгоритм:**
Цикл for ```i in range(1, len(arr))``` обрабатывает каждый элемент начиная со второго. Текущий элемент ```arr[i]``` сохраняется в ```key```. Переменная ```j = i - 1``` указывает на предыдущий элемент. Цикл ```while (j >= 0 and key < arr[j])``` сдвигает все элементы больше ```key``` на одну позицию вправо. Когда найдена правильная позиция, ```key``` вставляется командой ```arr[j + 1] = key```.
#### Сортировка вставками (Python)
Исходный массив: [12, 11, 13, 5, 6]
Отсортированный массив: [5, 6, 11, 12, 13]

#### **Оценка временной сложности:**
Время - ```O(n²)```

#### **Почему эта временная сложность?**
Временная сложность ```O(n²)``` возникает потому, что в худшем случае каждый новый элемент требует сравнения и сдвига всех предыдущих элементов, что приводит к ```n(n-1)/2``` операциям.

### **4. Анализ алгоритма сортировки слиянием**

#### **Определение:**
Сортировка слиянием ```(Merge Sort)``` — алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии.

#### **Как работает алгоритм:**
Функция ```mergeSort``` проверяет условие ```if (l < r)```. Если часть массива больше одного элемента, вычисляется середина ```m = l + (r - l) / 2```. Рекурсивно вызывается ```mergeSort``` для левой и правой половин. Затем вызывается функция ```merge``` для слияния отсортированных половин.
####  Сортировка слиянием (C++)
Исходный массив
12 11 13 5 6 7 
Отсортированный массив
5 6 7 11 12 13 

#### **Оценка временной сложности:**
Время - ```O(n log n)```

#### **Почему эта временная сложность:**
Временная сложность ```O(n log n)``` возникает потому, что массив делится пополам ```log n``` раз, и на каждом уровне рекурсии выполняется операция слияния всех ```n``` элементов.

### **5. Анализ алгоритма сортировки Шелла**

#### **Определение:**
Сортировка Шелла ```(Shell Sort)``` — является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу.

#### **Как работает алгоритм:**
Начинается с большого шага ```gap = n/2```. Внешний цикл ```for (int gap = n/2; gap > 0; gap /= 2)``` выполняется, пока шаг не станет нулевым. Для каждого шага внутренний цикл ```for (int i = gap; i < n; i++)``` обрабатывает элементы. Текущий элемент ```arr[i]``` сохраняется в ```temp```. Вложенный цикл ```for``` сдвигает элементы, превышающие ```temp```, на позиции с шагом ```gap```. Когда найдена позиция, temp записывается в ```arr[j]```.
####  Сортировка Шелла (Java)
Исходный массив: [12, 34, 54, 2, 3]
Отсортированный массив: [2, 3, 12, 34, 54]

#### **Оценка временной сложности:**
Время - O(n²)

#### **Почему эта временная сложность:**
Временная сложность ```O(n²)``` возникает потому, что для последовательности расстояний ```n/2, n/4, ..., 1``` в худшем случае может потребоваться квадратичное число операций.

### **6. Анализ алгоритма быстрой сортировки**

#### **Определение:**
Быстрая сортировка ```(Quick Sort)``` — алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного и рекурсивной сортировке частей.

#### **Как работает алгоритм:**
Проверяется условие ```if len(arr) <= 1```. Выбирается опорный элемент ```pivot = arr[len(arr) // 2]```. Массив разделяется на три части: ```left``` (элементы < ```pivot```), ```middle``` (элементы = ```pivot```), ```right``` (элементы > ```pivot```). Рекурсивно вызывается ```quicksort``` для ```left``` и ```right``` частей. Результат возвращается как ```quicksort(left) + middle + quicksort(right)```.
#### Быстрая сортировка (Python)
Отсортированный список: [1, 1, 2, 3, 6, 8, 10]

#### **Оценка временной сложности:**
Время - ```O(n log n)```

#### **Почему эта временная сложность:**
Временная сложность  ```O(n log n)``` возникает потому, что в среднем случае массив делится на примерно равные части на каждом уровне рекурсии, создавая ```log``` n уровней.

### **7. Анализ алгоритма пирамидальной сортировки**

#### **Определение:**
Пирамидальная сортировка ```(Heap Sort)``` — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.

#### **Как работает алгоритм:**
Сначала строится ```max-heap``` вызовами ```heapify``` для каждого элемента от ```n/2-1 до 0```. Затем для каждого элемента от ```n-1 до 0```: корень (максимальный элемент) перемещается в конец через ```swap(arr[0], arr[i])```, затем вызывается ```heapify``` для восстановления свойств кучи на уменьшенном массиве.

#### Пирамидальная сортировка (C++)
Исходный массив:
12 11 13 5 6 7 
Отсортированный массив:
5 6 7 11 12 13 

#### **Оценка временной сложности:**
Время - ```O(n log n)```

#### **Почему эта временная сложность:**
Временная сложность ```O(n log n)``` возникает потому, что построение кучи занимает ```O(n)``` времени, а каждое из n извлечений требует ```O(log n)```времени для перестройки кучи.

## Алгоритмы поиска

### **8. Анализ алгоритма линейного поиска**

#### **Определение:**
Линейный поиск ```(Linear Search)``` — простейший алгоритм поиска, который последовательно проверяет каждый элемент массива до тех пор, пока не найдет искомый элемент.

#### **Как работает алгоритм:**
Цикл ```for (int i = 0; i < arr.length; i++)``` последовательно перебирает элементы массива. На каждой итерации проверяется условие ```if (arr[i] == target)```. Если элемент найден, возвращается его индекс ```i```. Если цикл завершается без нахождения, возвращается -1.

#### Линейный поиск (Java)
80 находится на индексе 2

#### **Оценка временной сложности:**
Время - ```O(n)```

#### **Почему эта временная сложность:**
Временная сложность ```O(n)``` возникает потому, что в худшем случае алгоритму требуется проверить все ```n``` элементов массива.

### **9. Анализ алгоритма бинарного поиска**

#### **Определение:**
Бинарный поиск ```(Binary Search)``` — алгоритм поиска в отсортированном массиве, который на каждом шаге делит область поиска пополам.

#### **Как работает алгоритм:**
Используются два указателя ```low``` и ```high```. В цикле ```while low <= high``` вычисляется средний индекс ```mid = (low + high) // 2```. Если ```arr[mid] == target```, возвращается ```mid```. Если ```target < arr[mid]```, поиск продолжается в левой половине ```(high = mid - 1)```. Если ```target > arr[mid]```, поиск продолжается в правой половине ```(low = mid + 1)```.
#### Бинарный поиск (Python)
10 найден на индексе 3

#### **Оценка временной сложности:**
Время - ```O(log n)```

#### **Почему эта временная сложность:**
Временная сложность ```O(log n)``` возникает потому, что на каждом шаге область поиска уменьшается вдвое, что означает не более log₂n сравнений.

### **10. Анализ алгоритма интерполяционного поиска**

####  **Определение:**
Интерполяционный поиск ```(Interpolation Search)``` — алгоритм поиска для отсортированных массивов, который предсказывает позицию элемента на основе значений.

#### **Как работает алгоритм:**
Используется интерполяционная формула для вычисления позиции: ```pos = low + (((double)(high - low) / (arr[high] - arr[low])) * (target - arr[low]))```. В цикле ```while``` проверяется, находится ли ```target``` в текущем диапазоне. Если ```arr[pos] == target```, возвращается pos. Если ```arr[pos] < target```, поиск продолжается справа ```(low = pos + 1)```. Если ```arr[pos] > target```, поиск продолжается слева ```(high = pos - 1)```.

#### Интерполяционный поиск (C++)
Элемент 18 найден на индексе 4

#### **Оценка временной сложности:**
Время - ```O(log log n)```

#### **Почему эта временная сложность:**
Временная сложность ```O(log log n)``` возникает потому, что при равномерном распределении данных алгоритм экспоненциально уменьшает область поиска на каждом шаге.

### **11. Анализ алгоритма поиска по Фибоначчи**

#### **Определение:**
Поиск по Фибоначчи ```(Fibonacci Search)``` — алгоритм поиска, использующий числа Фибоначчи для определения позиций сравнения.

#### **Как работает алгоритм:**
Сначала генерируется последовательность Фибоначчи до числа ```fibM```, превышающего длину массива. В цикле ```while fibM > 1``` вычисляется позиция ```i = Math.min(offset+fibMm2, arr.length-1)```. Если ```arr[i] < target```, поиск продолжается справа. Если ```arr[i] > target```, поиск продолжается слева. Если ```arr[i] == target```, возвращается ```i```. В завершении проверяется последний возможный элемент.

#### Поиск по Фибоначчи (Java)
35 найден на индексе 2

#### **Оценка временной сложности:**
Время - ```O(log n)```
#### **Почему эта временная сложность:**
Временная сложность ```O(log n)``` возникает потому, что алгоритм делит массив с помощью чисел Фибоначчи, которые растут экспоненциально, что гарантирует логарифмическое количество сравнений.

