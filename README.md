# **Аналитическая работа по алгоритмическим структурам сортировки и поиска на языках: C++, Python, Java. (Виговская Катя, УИБО-10-24)**

### Алгоритмы сортировки

**1. Анализ алгоритма сортировки выбором**

**Определение:**
Сортировка выбором (Selection Sort) — это алгоритм, который на каждом шаге находит минимальный элемент в неотсортированной части массива и меняет его местами с текущим элементом.

**Как работает алгоритм:**
Программа запускается из main, где создается массив и вызывается selectionSort(). В методе сортировки внешний цикл for проходит по всем элементам массива. Для каждой позиции i внутренний цикл for ищет минимальный элемент в оставшейся части массива. Когда находится меньший элемент (if (arr[j] < arr[minIndex])), запоминается его позиция minIndex = j. После завершения внутреннего цикла элементы меняются местами через функцию swap(). Процесс повторяется для каждой позиции, постепенно формируя отсортированный массив.

**Оценка временной сложности:**
Время - O(n²), где n — длина массива;

**Почему эта временная сложность:**
Временная сложность O(n²) возникает потому, что выполняется n(n-1)/2 сравнений - для каждого элемента нужно проверить все оставшиеся элементы в неотсортированной части массива.

**2. Анализ алгоритма сортировки обменом (пузырьком)**

**Определение:**
Сортировка обменом (пузырьком) (Bubble Sort) — алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке.

**Как работает алгоритм:**
Метод bubbleSort использует флаг swapped для отслеживания обменов. Внешний цикл do-while выполняется до тех пор, пока происходят обмены. Внутренний цикл for проходит по массиву и сравнивает соседние элементы. Если текущий элемент больше следующего (if (array[i] > array[i+1])), происходит обмен через временную переменную temp. Флаг swapped устанавливается в true при каждом обмене. Процесс повторяется до полной сортировки массива.

**Оценка временной сложности:**
Время - O(n²), где n — длина массива;

**Почему эта временная сложность:**
Временная сложность O(n²) возникает потому, что в худшем случае требуется n-1 проходов по массиву, и на каждом проходе выполняется n-i сравнений, что в сумме дает n(n-1)/2 операций.

**3. Анализ алгоритма сортировки вставками**

**Определение:**
Сортировка вставками (Insertion Sort) — алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место в отсортированной части.

**Как работает алгоритм:**
Функция insertion_sort получает массив arr. Цикл for i in range(1, len(arr)) обрабатывает каждый элемент начиная со второго. Текущий элемент arr[i] сохраняется в key. Переменная j = i - 1 указывает на предыдущий элемент. Цикл while (j >= 0 and key < arr[j]) сдвигает все элементы больше key на одну позицию вправо. Когда найдена правильная позиция, key вставляется командой arr[j + 1] = key. Процесс повторяется для всех элементов.

**Оценка временной сложности:**
Время - O(n²), где n — длина массива;
Память - O(1).

**Почему эта временная сложность?**
Временная сложность O(n²) возникает потому, что в худшем случае каждый новый элемент требует сравнения и сдвига всех предыдущих элементов, что приводит к n(n-1)/2 операциям.

---

**4. Анализ алгоритма сортировки слиянием**

**Определение:**
Сортировка слиянием (Merge Sort) — алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии.

**Как работает алгоритм:**
Функция mergeSort проверяет условие if (l < r). Если часть массива больше одного элемента, вычисляется середина m = l + (r - l) / 2. Рекурсивно вызывается mergeSort для левой и правой половин. Затем вызывается функция merge для слияния. В merge создаются временные массивы L[] и R[], куда копируются элементы из соответствующих половин. Три указателя i, j, k используются для слияния: сравниваются элементы из временных массивов и меньший помещается в исходный массив. Когда один массив заканчивается, оставшиеся элементы копируются в конец.

**Оценка временной сложности:**
Время - O(n log n), где n — длина массива;


**Почему эта временная сложность:**
Временная сложность O(n log n) возникает потому, что массив делится пополам log n раз, и на каждом уровне рекурсии выполняется операция слияния всех n элементов.

---

**5. Анализ алгоритма сортировки Шелла**

**Определение:**
Сортировка Шелла (Shell Sort) — является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу.

**Как работает алгоритм:**
Метод shellSort начинает с большого шага gap = n/2. Внешний цикл for (int gap = n/2; gap > 0; gap /= 2) выполняется, пока шаг не станет нулевым. Для каждого шага внутренний цикл for (int i = gap; i < n; i++) обрабатывает элементы. Текущий элемент arr[i] сохраняется в temp. Вложенный цикл for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) сдвигает элементы, превышающие temp, на позиции с шагом gap. Когда найдена позиция, temp записывается в arr[j]. Процесс повторяется до полной сортировки.

**Оценка временной сложности:**
Время - O(n²), где n — длина массива;

**Почему эта временная сложность:**
Временная сложность O(n²) возникает потому, что для последовательности расстояний n/2, n/4, ..., 1 в худшем случае может потребоваться квадратичное число операций.

---

**6. Анализ алгоритма быстрой сортировки**

**Определение:**
Быстрая сортировка (Quick Sort) — алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного и рекурсивной сортировке частей.

**Как работает алгоритм:**
Функция quicksort проверяет условие if len(arr) <= 1. Выбирается опорный элемент pivot = arr[len(arr) // 2]. Массив разделяется на три части: left (элементы < pivot), middle (элементы = pivot), right (элементы > pivot). Рекурсивно вызывается quicksort для left и right частей. Результат возвращается как quicksort(left) + middle + quicksort(right).

**Оценка временной сложности:**
Время - O(n log n), где n — длина массива;

**Почему эта временная сложность:**
Временная сложность O(n log n) возникает потому, что в среднем случае массив делится на примерно равные части на каждом уровне рекурсии, создавая log n уровней.

---

**7. Анализ алгоритма пирамидальной сортировки**

**Определение:**
Пирамидальная сортировка (Heap Sort) — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.

**Как работает алгоритм:**
Функция heapSort сначала строит max-heap, вызывая heapify для каждого элемента от n/2-1 до 0. Затем для каждого элемента от n-1 до 0: корень (максимальный элемент) перемещается в конец через swap(arr[0], arr[i]), затем вызывается heapify для восстановления свойств кучи на уменьшенном массиве. Метод heapify проверяет, является ли узел root наибольшим среди него и его потомков. Если нет - происходит обмен с наибольшим потомком и рекурсивный вызов heapify.

**Оценка временной сложности:**
Время - O(n log n), где n — длина массива;

**Почему эта временная сложность:**
Временная сложность O(n log n) возникает потому, что построение кучи занимает O(n) времени, а каждое из n извлечений требует O(log n) времени для перестройки кучи.

---

### Алгоритмы поиска

**8. Анализ алгоритма линейного поиска**

**Определение:**
Линейный поиск (Linear Search) — простейший алгоритм поиска, который последовательно проверяет каждый элемент массива до тех пор, пока не найдет искомый элемент.

**Как работает алгоритм:**
Метод linearSearch получает массив arr и целевой элемент target. Цикл for (int i = 0; i < arr.length; i++) последовательно перебирает элементы массива. На каждой итерации проверяется условие if (arr[i] == target). Если элемент найден, возвращается его индекс i. Если цикл завершается без нахождения, возвращается -1.

**Оценка временной сложности:**
Время - O(n), где n — длина массива;

**Почему эта временная сложность:**
Временная сложность O(n) возникает потому, что в худшем случае алгоритму требуется проверить все n элементов массива.

---

**9. Анализ алгоритма бинарного поиска**

**Определение:**
Бинарный поиск (Binary Search) — алгоритм поиска в отсортированном массиве, который на каждом шаге делит область поиска пополам.

**Как работает алгоритм:**
Функция binary_search использует два указателя low и high. В цикле while low <= high вычисляется средний индекс mid = (low + high) // 2. Если arr[mid] == target, возвращается mid. Если target < arr[mid], поиск продолжается в левой половине (high = mid - 1). Если target > arr[mid], поиск продолжается в правой половине (low = mid + 1). Если элемент не найден, возвращается -1.

**Оценка временной сложности:**
Время - O(log n), где n — длина массива;

**Почему эта временная сложность:**
Временная сложность O(log n) возникает потому, что на каждом шаге область поиска уменьшается вдвое, что означает не более log₂n сравнений.

**10. Анализ алгоритма интерполяционного поиска**

**Определение:**
Интерполяционный поиск (Interpolation Search) — алгоритм поиска для отсортированных массивов, который предсказывает позицию элемента на основе значений.

**Как работает алгоритм:**
Функция interpolationSearch использует интерполяционную формулу для вычисления позиции: pos = low + (((double)(high - low) / (arr[high] - arr[low])) * (target - arr[low])). В цикле while проверяется, находится ли target в текущем диапазоне. Если arr[pos] == target, возвращается pos. Если arr[pos] < target, поиск продолжается справа (low = pos + 1). Если arr[pos] > target, поиск продолжается слева (high = pos - 1).

**Оценка временной сложности:**
Время - O(log log n), где n — длина массива;


**Почему эта временная сложность:**
Временная сложность O(log log n) возникает потому, что при равномерном распределении данных алгоритм экспоненциально уменьшает область поиска на каждом шаге.

**11. Анализ алгоритма поиска по Фибоначчи**

**Определение:**
Поиск по Фибоначчи (Fibonacci Search) — алгоритм поиска, использующий числа Фибоначчи для определения позиций сравнения.

**Как работает алгоритм:**
Метод fibMonaccianSearch генерирует последовательность Фибоначчи до числа ```fibM```, превышающего длину массива. В цикле ```while fibM > 1``` вычисляется позиция ```i = min(offset + fibMm2, arr.length-1)```. Если ```arr[i] < target```, поиск продолжается справа. Если ```arr[i] > target```, поиск продолжается слева. Если ```arr[i] == target```, возвращается i. В завершении проверяется последний возможный элемент.

**Оценка временной сложности:**
Время - O(log n), где n — длина массива

**Почему эта временная сложность:**
Временная сложность O(log n) возникает потому, что алгоритм делит массив с помощью чисел Фибоначчи, которые растут экспоненциально, что гарантирует логарифмическое количество сравнений.

