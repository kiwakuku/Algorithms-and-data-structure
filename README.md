# **Аналитическая работа по алгоритмическим структурам сортировки и поиска на языках: C++, Python, Java. (Виговская Катя, УИБО-10-24)**
## 1. Алгоритм сортировки выбором (Selection Sort)

### Определение:
Сортировка выбором (Selection Sort) — это алгоритм, который последовательно находит минимальные элементы неотсортированной части массива и помещает их на правильную позицию в отсортированной части. Таким образом, каждый проход алгоритма гарантирует размещение одного элемента на своем окончательном месте.

### Анализ:
**Основные функции:**
- `selectionSort()` - основная функция сортировки выбором

**Ключевые переменные:**
- `minIndex` - индекс минимального элемента в неотсортированной части
- `i, j` - индексы для внешнего и внутреннего циклов
- `n` - размер массива

**Процесс работы:**
Алгоритм состоит из двух вложенных циклов. Внешний цикл проходит по всем элементам массива. Внутренний цикл находит минимальный элемент в неотсортированной части массива. После завершения внутреннего цикла найденный минимальный элемент меняется местами с первым элементом неотсортированной части.

### Временная сложность:
- Лучший случай: ```O(n²)```
- Средний случай: ```O(n²)```
- Худший случай: ```O(n²)```

### Почему именно так?
Даже если массив уже частично отсортирован, алгоритм всё равно вынужден пройти по всей неотсортированной области, сравнивая все оставшиеся элементы друг с другом. Каждый раз приходится искать новый минимум, даже если он очевиден. Количество сравнений всегда равно n(n-1)/2, что дает квадратичную сложность независимо от начального состояния массива.

---

## 2. Алгоритм сортировки пузырьком (Bubble Sort)

### Определение:
Алгоритм "Bubble Sort" основывается на последовательном сравнении пар соседних элементов и их обмене местами, если порядок нарушен. Более легкие элементы "всплывают" к началу массива, а тяжелые - "опускаются" к концу. Процесс повторяется многократно, пока массив не станет полностью упорядоченным.

### Анализ:
**Основные функции:**
- `bubbleSort()` - основная функция сортировки пузырьком

**Ключевые переменные:**
- `swapped` - флаг, указывающий на наличие перестановок на текущей итерации
- `i, j` - индексы для циклов
- `temp` - временная переменная для обмена элементов
- `n` - размер массива

**Процесс работы:**
Алгоритм проходит по массиву несколько раз. На каждой итерации сравниваются соседние элементы, и если они находятся в неправильном порядке, происходит их обмен. Процесс повторяется до тех пор, пока на всей протяженности массива не останется ни одной необходимой перестановки.

### Временная сложность:
- Лучший случай: ```O(n)``` (уже отсортированный массив)
- Средний случай: ```O(n²)```
- Худший случай: ```O(n²)``` (обратно отсортированный массив)

### Почему именно так?
В худшем случае (массив отсортирован в обратном порядке) требуется n-1 проходов, и на каждом проходе выполняется n-i сравнений. Суммарное количество операций составляет n(n-1)/2, что дает квадратичную сложность. В лучшем случае с оптимизацией (флаг swapped) достаточно одного прохода.

---

## 3. Алгоритм сортировки вставками (Insertion Sort)

### Определение:
Алгоритм сортировки вставками (Insertion Sort) — простой алгоритм сортировки, работающий аналогично процессу упорядочивания карт вручную. Его идея заключается в последовательном переносе каждого элемента на нужную позицию среди ранее отсортированных элементов. Каждый новый элемент "вставляется" в правильное место в уже отсортированной левой части массива.

### Анализ:
**Основные функции:**
- `insertion_sort()` - основная функция сортировки вставками

**Ключевые переменные:**
- `key` - текущий элемент для вставки
- `j` - индекс для перемещения по отсортированной части
- `i` - индекс текущего элемента во внешнем цикле

**Процесс работы:**
Алгоритм начинает со второго элемента массива. Для каждого текущего элемента он находит правильную позицию в отсортированной левой части, сдвигая элементы большие текущего вправо, и вставляет текущий элемент на найденную позицию. Процесс повторяется для всех элементов массива.

### Временная сложность:
- Лучший случай: ```O(n)``` (уже отсортированный массив)
- Средний случай: ```O(n²)```
- Худший случай: ```O(n²)``` (обратно отсортированный массив)

### Почему именно так?
В худшем случае каждый новый элемент приходится сравнивать со всеми элементами отсортированной части, что требует 1 + 2 + 3 + ... + (n-1) = n(n-1)/2 сравнений, что дает квадратичную сложность. В лучшем случае массив уже отсортирован, и для каждого элемента требуется только одно сравнение.

## **Аналитическая работа по алгоритмическим структурам сортировки и поиска**

## 4. Алгоритм сортировки слиянием (Merge Sort)

### Определение:
Сортировка слиянием (Merge Sort) — это алгоритм «разделяй и властвуй», который рекурсивно разделяет массив на две половины, сортирует каждую половину, а затем объединяет отсортированные половины в один отсортированный массив.

### Анализ:
**Основные функции:**
- `mergeSort()` - рекурсивная функция разделения массива
- `merge()` - функция слияния двух отсортированных подмассивов

**Ключевые переменные:**
- `mid` - индекс середины массива для разделения
- `left[]`, `right[]` - временные подмассивы
- `i, j, k` - индексы для слияния подмассивов

**Процесс работы:**
Функция `mergeSort` рекурсивно делит массив до подмассивов из одного элемента, затем функция `merge` объединяет их в отсортированном порядке, сравнивая элементы и выбирая наименьший.

### Временная сложность:
- Лучший случай: ```O(n log n)```
- Средний случай: ```O(n log n)```
- Худший случай: ```O(n log n)```

### Почему именно так?
Алгоритм всегда делит массив пополам (log n уровней деления) и на каждом уровне выполняет слияние за ```O(n)``` операций. Поскольку количество уровней деления равно log₂n, общая сложность составляет ```O(n log n)``` во всех случаях.

---

## 5. Алгоритм сортировки Шелла (Shell Sort)

### Определение:
Сортировка Шелла — это усовершенствованный вариант сортировки вставками, который сортирует элементы, находящиеся на определенном расстоянии друг от друга, постепенно уменьшая это расстояние.

### Анализ:
**Основные функции:**
- `shellSort()` - основная функция сортировки

**Ключевые переменные:**
- `gap` - текущий промежуток между сравниваемыми элементами
- `temp` - временная переменная для обмена
- `i, j` - индексы для прохода по массиву

**Процесс работы:**
Начинается с большого промежутка `gap`, который постепенно уменьшается. Для каждого промежутка выполняется сортировка вставками элементов, отстоящих друг от друга на расстоянии `gap`.

### Временная сложность:
- Зависит от выбранной последовательности промежутков
- Лучший случай: ```O(n log n)```
- Худший случай: ```O(n²)```

### Почему именно так?
Сложность зависит от последовательности промежутков. При оптимальной последовательности достигается ```O(n log²n)```, но в худшем случае может деградировать до квадратичной, как у простой сортировки вставками.

---

## 6. Алгоритм быстрой сортировки (Quick Sort)

### Определение:
Быстрая сортировка — это алгоритм «разделяй и властвуй», который выбирает опорный элемент и перераспределяет другие элементы вокруг него так, чтобы меньшие элементы оказались слева, а большие — справа.

### Анализ:
**Основные функции:**
- `quickSort()` - рекурсивная функция сортировки
- `partition()` - функция разделения массива относительно опорного элемента

**Ключевые переменные:**
- `pivot` - опорный элемент
- `i` - индекс для отслеживания позиции разделения
- `low, high` - границы текущего подмассива

**Процесс работы:**
Функция `partition` перераспределяет элементы так, чтобы все элементы меньше `pivot` были слева, а больше - справа. Функция `quickSort` рекурсивно применяет этот процесс к обеим частям.

### Временная сложность:
- Лучший случай: ```O(n log n)```
- Средний случай: ```O(n log n)```
- Худший случай: ```O(n²)```

### Почему именно так?
В худшем случае (уже отсортированный массив и неудачный выбор опорного элемента) разделение происходит максимально несбалансированно, что приводит к квадратичной сложности. В среднем случае разделение близко к идеальному.

---

## 7. Алгоритм пирамидальной сортировки (Heap Sort)

### Определение:
Пирамидальная сортировка использует структуру данных «двоичная куча» для сортировки элементов. Алгоритм строит max-heap из массива и последовательно извлекает максимальный элемент.

### Анализ:
**Основные функции:**
- `heapSort()` - основная функция сортировки
- `heapify()` - функция построения/восстановления кучи

**Ключевые переменные:**
- `n` - размер кучи/массива
- `largest` - индекс наибольшего элемента
- `left, right` - индексы левого и правого потомков

**Процесс работы:**
Функция `heapify` обеспечивает выполнение свойства кучи для поддерева. Функция `heapSort` сначала строит max-heap, затем последовательно извлекает корневой элемент (максимальный) и перестраивает кучу.

### Временная сложность:
- Лучший случай: ```O(n log n)```
- Средний случай: ```O(n log n)```
- Худший случай: ```O(n log n)```

### Почему именно так?
Построение кучи занимает O(n) времени, а каждая из n операций извлечения занимает O(log n) времени, что в сумме дает O(n log n) во всех случаях.

---

## 8. Алгоритм последовательного (линейный) поиска (Linear Search)

### Определение:
Линейный поиск — простейший алгоритм поиска, который последовательно проверяет каждый элемент массива до тех пор, пока не найдет искомый элемент или не достигнет конца массива.

### Анализ:
**Основные функции:**
- `linearSearch()` - функция линейного поиска

**Ключевые переменные:**
- `key` - искомый элемент
- `index` - текущий индекс при проходе по массиву
- `found` - флаг нахождения элемента

**Процесс работы:**
Функция последовательно сравнивает каждый элемент массива с искомым значением `key`. Если элемент найден, возвращает его индекс, иначе возвращает -1.

### Временная сложность:
- Лучший случай: ```O(1)``` (элемент первый)
- Средний случай: ```O(n)```
- Худший случай: ```O(n)``` (элемент последний или отсутствует)

### Почему именно так?
В худшем случае необходимо проверить все n элементов массива, что дает линейную сложность O(n).

---

## 9. Алгоритм бинарного поиска (Binary Search)

### Определение:
Бинарный поиск — эффективный алгоритм поиска в отсортированном массиве, который на каждом шаге делит область поиска пополам.

### Анализ:
**Основные функции:**
- `binarySearch()` - рекурсивная/итеративная функция поиска

**Ключевые переменные:**
- `low, high` - границы текущей области поиска
- `mid` - средний индекс области поиска
- `target` - искомый элемент

**Процесс работы:**
На каждой итерации вычисляется `mid` - середина текущего диапазона. Если `target` равен элементу с индексом `mid`, поиск завершен. Если меньше, поиск продолжается в левой половине, иначе - в правой.

### Временная сложность:
- Лучший случай: ```O(1)``` (элемент в середине)
- Средний случай: ```O(log n)```
- Худший случай: ```O(log n)```

### Почему именно так?
На каждой итерации область поиска уменьшается вдвое, поэтому максимальное количество итераций равно log₂n.

## 10. Алгоритм интерполирующего поиска (Interpolation Search)

### Определение:
Интерполяционный поиск — усовершенствованный вариант бинарного поиска, который использует значения элементов для вычисления вероятного положения искомого элемента.

### Анализ:
**Основные функции:**
- `interpolationSearch()` - функция интерполяционного поиска

**Ключевые переменные:**
- `pos` - вычисленная позиция искомого элемента
- `low, high` - границы поиска
- `delta` - значение для интерполяционной формулы

**Процесс работы:**
Использует формулу интерполяции для вычисления вероятной позиции элемента: `pos = low + ((target - arr[low]) * (high - low)) / (arr[high] - arr[low])`. На каждой итерации обновляет границы поиска на основе сравнения.

### Временная сложность:
- Лучший случай: ```O(1)```
- Средний случай: ```O(log log n)```
- Худший случай: ```O(n)```

### Почему именно так?
В худшем случае (неравномерное распределение) алгоритм может деградировать до линейного поиска. В среднем случае для равномерно распределенных данных сложность составляет O(log log n).

---

## 11. Алгоритм поиска по Фибоначчи (Fibonacci Search)

### Определение:
Поиск Фибоначчи — это алгоритм поиска, использующий числа Фибоначчи для разделения массива. Является улучшенной версией бинарного поиска.

### Анализ:
**Основные функции:**
- `fibonacciSearch()` - функция поиска по Фибоначчи

**Ключевые переменные:**
- `fibM`, `fibM1`, `fibM2` - числа Фибоначчи для определения точек разделения
- `offset` - смещение для текущей области поиска
- `i` - текущий индекс для сравнения

**Процесс работы:**
Использует числа Фибоначчи для определения точек разделения массива. На каждой итерации сравнивает элемент с искомым значением и соответствующим образом обновляет числа Фибоначчи и смещение.

### Временная сложность:
- Лучший случай: ```O(1)```
- Средний и худший случаи: ```O(log n)```

### Почему именно так?
Алгоритм делит массив в золотом сечении, что обеспечивает логарифмическую сложность, аналогичную бинарному поиску, но с более эффективными операциями сравнения.
