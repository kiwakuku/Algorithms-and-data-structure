# ***Алгоритмы сортировки***
## Алгоритм сортировки выбором для C++
Является одним из простейших методов сортировки массивов. Основная идея заключается в последовательном поиске минимального элемента среди оставшихся элементов массива и перемещении его на правильное место в отсортированной части массива.
### Как работает:
- Внешний цикл выбирает позицию для вставки следующего минимального элемента.
- Внутренний цикл ищет минимальный элемент справа от выбранной позиции.
- Минимальный элемент ставится на своё место путём перестановки.
- На выходе получилось: "Отсортированный массив:
3 5 11 12 22 25 64 90" 
### Сложность: 
O(n2) — медленно растёт с размером массива.

## Алгоритм сортировки пузырьком («Bubble Sort»)
Это простой метод сортировки, основанный на многократном сравнении соседних элементов и их замене друг с другом, пока весь массив не окажется упорядоченным.
### Как работает:
- Внешний цикл регулирует количество полных проходов по массиву.
- Внутренний цикл сравнивает соседние элементы и меняет их местами, если предыдущий больше последующего.
- На выходе получилось:
### Сложность: 
- O(n2).

## Алгоритм сортировки вставками
Представляет собой эффективный способ сортировки небольших массивов или частично отсортированных списков. Его основная идея состоит в постепенном расширении отсортированной части списка путем перемещения новых элементов на подходящие места внутри неё.
### Как работает:
- Берём второй элемент массива и ставим его на правильное место относительно первого элемента.
- Затем берём третий элемент и вставляем его на нужное место среди предыдущих двух.
- Повторяем этот процесс для каждого последующего элемента, двигаясь по массиву.
- На выходе получилось:
Каждый элемент вставляется в отсортированную часть массива, сдвигая больший элемент вперед, пока не найдёт своё место.
### Временная сложность:
- O(n2) в худшем и среднем случае, O(n) — лучший случай (если массив уже отсортирован).

## Алгоритм сортировки слиянием
Основан на подходе «разделяй и властвуй»: массив делится рекурсивно на две половины, каждая половина сортируется отдельно, а затем обе половинки объединяются обратно в единый отсортированный массив.
### Как работает:
- Массив делится пополам рекурсивно до тех пор, пока не останутся отдельные элементы.
- Отдельные элементы автоматически являются отсортированными.
- Далее эти маленькие отсортированные куски сливаются вместе в большие отсортированные фрагменты.
- Итоговый массив получается полностью отсортированным.
### Оценка временной сложности: 
- O (nlogn).

## Алгоритм сортировки Шелла (Shell Sort)
Это улучшенная версия сортировки вставками, использующая идею частичного упорядочивания элементов с большим шагом, а затем уменьшения шага вплоть до единичного интервала, когда массив становится почти отсортированным.
### Как работает:
- Массив сначала сортируется большими шагами, удаляя далеко стоящие элементы друг от друга.
- Потом шаг уменьшается, снова сортируя элементы с новым расстоянием.
- Последовательно уменьшают шаг, пока он не достигнет единицы, окончательно упорядочивая массив.
### Сложность: 
- O(N3/2) в классическом варианте, при оптимальной стратегии выбора шагов достигает O(N⋅logN).

## Быстрая сортировка (Quicksort)
Это высокоэффективный алгоритм сортировки, основанный на принципе «разделяй и властвуй». Основная идея заключается в выборе опорного элемента (pivot), разделении массива на две части (элементы меньше pivot и элементы больше pivot), после чего каждая часть рекурсивно сортируется аналогично.
### Как работает:
- Выбираем опорный элемент (pivot).
- Делим массив на три группы: элементы меньше pivot, равные pivot и больше pivot.
- Рекурсивно сортируем левую и правую подгруппы.
- Объединяем отсортированные части, включая группу равных элементов.
### Временная сложность:
- Средняя и лучшая: O(n log n)
- Худшая: O(n2) (редкий случай)

## Пирамидальная сортировка (Heap Sort)
Это эффективный алгоритм сортировки, основанный на структуре бинарной кучи. Бинарная куча — это дерево, в котором родительские узлы всегда больше (или меньше) своих дочерних узлов.
### Как работает алгоритм:
1.	Постройка кучи:
- Преобразовываем массив в структуру binary heap (max-куча), где каждый родительский узел больше своих детей.
2.	Извлечение элементов:
- Максимальный элемент (корень кучи) переносится в конец массива.
- Структура кучи обновляется для оставшихся элементов.
- Повторяем операцию, пока массив не будет отсортирован.
### Временная сложность: 
- O(n log n).

# ***Алгоритмы поиска***
## Последовательный (линейный) поиск 
Это базовый алгоритм поиска элемента в коллекции, при котором осуществляется просмотр каждого элемента по порядку, пока искомый элемент не будет найден либо не закончится коллекция.
### Как работает:
- Линейный поиск просматривает массив последовательно, начиная с первого элемента.
- Если текущий элемент совпадает с искомым, немедленно возвращается его индекс.
- Если искомого элемента нет, пройдя весь массив, вернётся значение -1.
### Временная сложность:
- Средний и худший случаи: O(n) (необходимо пройти весь массив).

## Бинарный (двоичный) поиск
Это быстрый алгоритм поиска элемента в отсортированном массиве. Идея заключается в том, чтобы постоянно делить диапазон поиска пополам, исключая ненужные области массива, основываясь на сравнении центрального элемента с искомым значением.
### Как работает алгоритм:
- На каждом шаге бинарный поиск уменьшает область поиска вдвое, исключая половину массива, где точно нет искомого элемента.
- Таким образом, с каждым шагом область поиска сужается экспоненциально, что значительно ускоряет поиск по сравнению с простым линейным поиском.
На выходе получается «Элемент 7 найден на позиции 3»
### Временная сложность: 
- O(logn)

## Поиск по Фибоначчи (Fibonacci Search) 
Это усовершенствованный вариант бинарного поиска, в котором деление массива на части основано на числах Фибоначчи. Вместо простого разделения массива пополам, алгоритм использует последовательность Фибоначчи для вычисления точек раздела.
### Как работает алгоритм:
Сначала определяется наименьшее число Фибоначчи, превышающее или равное длине массива.
- Используя соотношение чисел Фибоначчи, массив делится на две части: большую и меньшую.
- Сравнение происходит с элементом, находящимся в точке деления.
- В зависимости от результата сравнения, поиск продолжается в большей или меньшей части массива.
- Этот процесс повторяется до тех пор, пока не будет найден нужный элемент или исчерпаны возможные варианты.
На выходе получается «Элемент не найден»
### Временная сложность: 
- O(logφn),  где φ ≈ 1.618, золотое сечение.


