# **Аналитическая работа по алгоритмическим структурам сортировки и поиска на языках: C++, Python, Java. (Виговская Катя, УИБО-10-24)**
## 1. Алгоритм сортировки выбором (Selection Sort)

### Определение:
Сортировка выбором (Selection Sort) — это алгоритм, который последовательно находит минимальные элементы неотсортированной части массива и помещает их на правильную позицию в отсортированной части. Таким образом, каждый проход алгоритма гарантирует размещение одного элемента на своем окончательном месте.

### Анализ:
Алгоритм состоит из двух вложенных циклов. Внешний цикл проходит по всем элементам массива, внутренний цикл находит минимальный элемент в неотсортированной части массива. После завершения внутреннего цикла найденный минимальный элемент меняется местами с первым элементом неотсортированной части.

**Ключевые переменные:** `minIndex` (индекс минимального элемента), `i, j` (индексы циклов), `n` (размер массива)

### Временная сложность:
- Лучший случай: ```O(n²)```
- Средний случай: ```O(n²)```
- Худший случай: ```O(n²)```

### Почему именно так?
Даже если массив уже частично отсортирован, алгоритм всё равно вынужден пройти по всей неотсортированной области, сравнивая все оставшиеся элементы друг с другом. Количество сравнений всегда равно n(n-1)/2, что дает квадратичную сложность независимо от начального состояния массива.

---

## 2. Алгоритм сортировки пузырьком (Bubble Sort)

### Определение:
Алгоритм "Bubble Sort" основывается на последовательном сравнении пар соседних элементов и их обмене местами, если порядок нарушен. Более легкие элементы "всплывают" к началу массива, а тяжелые - "опускаются" к концу. Процесс повторяется многократно, пока массив не станет полностью упорядоченным.

### Анализ:
Алгоритм проходит по массиву несколько раз. На каждой итерации сравниваются соседние элементы, и если они находятся в неправильном порядке, происходит их обмен. Процесс повторяется до тех пор, пока на всей протяженности массива не останется ни одной необходимой перестановки.

**Ключевые переменные:** `swapped` (флаг перестановок), `i, j` (индексы циклов), `temp` (временная переменная), `n` (размер массива)

### Временная сложность:
- Лучший случай: ```O(n)``` (уже отсортированный массив)
- Средний случай: ```O(n²)```
- Худший случай: ```O(n²)``` (обратно отсортированный массив)

### Почему именно так?
В худшем случае требуется n-1 проходов, и на каждом проходе выполняется n-i сравнений. Суммарное количество операций составляет n(n-1)/2, что дает квадратичную сложность. В лучшем случае с оптимизацией (флаг swapped) достаточно одного прохода.

---

## 3. Алгоритм сортировки вставками (Insertion Sort)

### Определение:
Алгоритм сортировки вставками (Insertion Sort) — простой алгоритм сортировки, работающий аналогично процессу упорядочивания карт вручную. Его идея заключается в последовательном переносе каждого элемента на нужную позицию среди ранее отсортированных элементов.

### Анализ:
Алгоритм начинает со второго элемента массива. Для каждого текущего элемента он находит правильную позицию в отсортированной левой части, сдвигая элементы большие текущего вправо, и вставляет текущий элемент на найденную позицию. Процесс повторяется для всех элементов массива.

**Ключевые переменные:** `key` (текущий элемент для вставки), `j` (индекс для перемещения), `i` (индекс текущего элемента)

### Временная сложность:
- Лучший случай: ```O(n)``` (уже отсортированный массив)
- Средний случай: ```O(n²)```
- Худший случай: ```O(n²)``` (обратно отсортированный массив)

### Почему именно так?
В худшем случае каждый новый элемент приходится сравнивать со всеми элементами отсортированной части, что требует 1 + 2 + 3 + ... + (n-1) = n(n-1)/2 сравнений. В лучшем случае массив уже отсортирован, и для каждого элемента требуется только одно сравнение.

---

## 4. Алгоритм сортировки слиянием (Merge Sort)

### Определение:
Сортировка слиянием (Merge Sort) — это алгоритм «разделяй и властвуй», который рекурсивно разделяет массив на две половины, сортирует каждую половину, а затем объединяет отсортированные половины в один отсортированный массив.

### Анализ:
Функция `mergeSort` рекурсивно делит массив до подмассивов из одного элемента, затем функция `merge` объединяет их в отсортированном порядке, сравнивая элементы и выбирая наименьший. Процесс включает разделение массива и последующее слияние отсортированных частей.

**Ключевые переменные:** `mid` (индекс середины), `left[], right[]` (временные подмассивы), `i, j, k` (индексы для слияния)

### Временная сложность:
- Лучший случай: ```O(n log n)```
- Средний случай: ```O(n log n)```
- Худший случай: ```O(n log n)```

### Почему именно так?
Алгоритм всегда делит массив пополам (log n уровней деления) и на каждом уровне выполняет слияние за ```O(n)``` операций. Поскольку количество уровней деления равно log₂n, общая сложность составляет ```O(n log n)``` во всех случаях.

---

## 5. Алгоритм сортировки Шелла (Shell Sort)

### Определение:
Сортировка Шелла — это усовершенствованный вариант сортировки вставками, который сортирует элементы, находящиеся на определенном расстоянии друг от друга, постепенно уменьшая это расстояние.

### Анализ:
Начинается с большого промежутка `gap`, который постепенно уменьшается. Для каждого промежутка выполняется сортировка вставками элементов, отстоящих друг от друга на расстоянии `gap`. Это позволяет элементам быстрее перемещаться в свои правильные позиции.

**Ключевые переменные:** `gap` (текущий промежуток), `temp` (временная переменная), `i, j` (индексы для прохода)

### Временная сложность:
- Зависит от выбранной последовательности промежутков
- Лучший случай: ```O(n log n)```
- Худший случай: ```O(n²)```

### Почему именно так?
Сложность зависит от последовательности промежутков. При оптимальной последовательности достигается ```O(n log²n)```, но в худшем случае может деградировать до квадратичной, как у простой сортировки вставками.

---

## 6. Алгоритм быстрой сортировки (Quick Sort)

### Определение:
Быстрая сортировка — это алгоритм «разделяй и властвуй», который выбирает опорный элемент и перераспределяет другие элементы вокруг него так, чтобы меньшие элементы оказались слева, а большие — справа.

### Анализ:
Функция `partition` перераспределяет элементы так, чтобы все элементы меньше `pivot` были слева, а больше - справа. Функция `quickSort` рекурсивно применяет этот процесс к обеим частям. Процесс включает выбор опорного элемента и разделение массива относительно него.

**Ключевые переменные:** `pivot` (опорный элемент), `i` (индекс разделения), `low, high` (границы подмассива)

### Временная сложность:
- Лучший случай: ```O(n log n)```
- Средний случай: ```O(n log n)```
- Худший случай: ```O(n²)```

### Почему именно так?
В худшем случае (уже отсортированный массив и неудачный выбор опорного элемента) разделение происходит максимально несбалансированно, что приводит к квадратичной сложности. В среднем случае разделение близко к идеальному.

---

## 7. Алгоритм пирамидальной сортировки (Heap Sort)

### Определение:
Пирамидальная сортировка использует структуру данных «двоичная куча» для сортировки элементов. Алгоритм строит max-heap из массива и последовательно извлекает максимальный элемент.

### Анализ:
Функция `heapify` обеспечивает выполнение свойства кучи для поддерева. Функция `heapSort` сначала строит max-heap, затем последовательно извлекает корневой элемент (максимальный) и перестраивает кучу. Процесс включает построение кучи и последовательное извлечение элементов.

**Ключевые переменные:** `n` (размер кучи), `largest` (индекс наибольшего элемента), `left, right` (индексы потомков)

### Временная сложность:
- Лучший случай: ```O(n log n)```
- Средний случай: ```O(n log n)```
- Худший случай: ```O(n log n)```

### Почему именно так?
Построение кучи занимает O(n) времени, а каждая из n операций извлечения занимает O(log n) времени, что в сумме дает O(n log n) во всех случаях.

---

## 8. Алгоритм последовательного (линейный) поиска (Linear Search)

### Определение:
Линейный поиск — простейший алгоритм поиска, который последовательно проверяет каждый элемент массива до тех пор, пока не найдет искомый элемент или не достигнет конца массива.

### Анализ:
Функция последовательно сравнивает каждый элемент массива с искомым значением `key`. Если элемент найден, возвращает его индекс, иначе возвращает -1. Процесс включает поочередную проверку каждого элемента массива.

**Ключевые переменные:** `key` (искомый элемент), `index` (текущий индекс), `found` (флаг нахождения)

### Временная сложность:
- Лучший случай: ```O(1)``` (элемент первый)
- Средний случай: ```O(n)```
- Худший случай: ```O(n)``` (элемент последний или отсутствует)

### Почему именно так?
В худшем случае необходимо проверить все n элементов массива, что дает линейную сложность O(n).

---

## 9. Алгоритм бинарного поиска (Binary Search)

### Определение:
Бинарный поиск — эффективный алгоритм поиска в отсортированном массиве, который на каждом шаге делит область поиска пополам.

### Анализ:
На каждой итерации вычисляется `mid` - середина текущего диапазона. Если `target` равен элементу с индексом `mid`, поиск завершен. Если меньше, поиск продолжается в левой половине, иначе - в правой. Процесс включает многократное деление области поиска пополам.

**Ключевые переменные:** `low, high` (границы области), `mid` (средний индекс), `target` (искомый элемент)

### Временная сложность:
- Лучший случай: ```O(1)``` (элемент в середине)
- Средний случай: ```O(log n)```
- Худший случай: ```O(log n)```

### Почему именно так?
На каждой итерации область поиска уменьшается вдвое, поэтому максимальное количество итераций равно log₂n.

---

## 10. Алгоритм интерполирующего поиска (Interpolation Search)

### Определение:
Интерполяционный поиск — усовершенствованный вариант бинарного поиска, который использует значения элементов для вычисления вероятного положения искомого элемента.

### Анализ:
Использует формулу интерполяции для вычисления вероятной позиции элемента: `pos = low + ((target - arr[low]) * (high - low)) / (arr[high] - arr[low])`. На каждой итерации обновляет границы поиска на основе сравнения. Процесс включает вычисление вероятной позиции и корректировку границ поиска.

**Ключевые переменные:** `pos` (вычисленная позиция), `low, high` (границы поиска), `delta` (значение для формулы)

### Временная сложность:
- Лучший случай: ```O(1)```
- Средний случай: ```O(log log n)```
- Худший случай: ```O(n)```

### Почему именно так?
В худшем случае (неравномерное распределение) алгоритм может деградировать до линейного поиска. В среднем случае для равномерно распределенных данных сложность составляет O(log log n).

---

## 11. Алгоритм поиска по Фибоначчи (Fibonacci Search)

### Определение:
Поиск Фибоначчи — это алгоритм поиска, использующий числа Фибоначчи для разделения массива. Является улучшенной версией бинарного поиска.

### Анализ:
Использует числа Фибоначчи для определения точек разделения массива. На каждой итерации сравнивает элемент с искомым значением и соответствующим образом обновляет числа Фибоначчи и смещение. Процесс включает использование золотого сечения для определения точек разделения.

**Ключевые переменные:** `fibM`, `fibM1`, `fibM2` (числа Фибоначчи), `offset` (смещение), `i` (текущий индекс)

### Временная сложность:
- Лучший случай: ```O(1)```
- Средний и худший случаи: ```O(log n)```

### Почему именно так?
Алгоритм делит массив в золотом сечении, что обеспечивает логарифмическую сложность, аналогичную бинарному поиску, но с более эффективными операциями сравнения.
