# Алгоритмы сортировки
## Алгоритм сортировки выбором является одним из простейших методов сортировки массивов. Основная идея заключается в последовательном поиске минимального элемента среди оставшихся элементов массива и перемещении его на правильное место в отсортированной части массива.

#include <iostream>
using namespace std;
// Функция сортировки выбором
void selectionSort(int arr[], int n) {
    // Внешний цикл проходит по каждому элементу массива,
    // начиная с первого и заканчивая предпоследним элементом
    for (int i = 0; i < n - 1; ++i) {  // Мы обрабатываем каждый элемент последовательно
        // Предполагаем, что минимальный элемент находится на текущей позиции i
        int minIndex = i;
        // Внутренний цикл ищет минимальный элемент в оставшейся несортированной части массива
        for (int j = i + 1; j < n; ++j) {
            if (arr[j] < arr[minIndex]) {  // Если нашли элемент меньше текущего минимума
                minIndex = j;              // Обновляем индекс минимального элемента
            }
        }
         // Меняем местами найденный минимум с текущим элементом
        swap(arr[i], arr[minIndex]);       // Используем стандартную функцию swap() для замены значений
    }
}
// Функция вывода массива
void printArray(const int arr[], int size) {
    cout << "Отсортированный массив: ";
    for (int i = 0; i < size; ++i)
        cout << arr[i] << ' ';
    cout << endl;
}
// Главная функция программы
int main() {
    const int SIZE = 8;      // Размер массива фиксирован
    int array[] = {64, 25, 12, 22, 11, 33, 99, 7};   // Пример исходного массива
    // Выполняем сортировку
    selectionSort(array, SIZE);
    // Выводим отсортированный массив
    printArray(array, SIZE);

    return 0;
}
## Как работает:
•	Внешний цикл выбирает позицию для вставки следующего минимального элемента.
•	Внутренний цикл ищет минимальный элемент справа от выбранной позиции.
•	Минимальный элемент ставится на своё место путём перестановки.
После вывода получается «Отсортированный массив: 7 11 12 22 25 33 64 99»
## Сложность: O(n2) — медленно растёт с размером массива.

## Алгоритм сортировки пузырьком («Bubble Sort») — это простой метод сортировки, основанный на многократном сравнении соседних элементов и их замене друг с другом, пока весь массив не окажется упорядоченным.
public class BubbleSortExample {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;                     // Длина массива
        boolean swapped;                        // Флаг для отслеживания наличия замен

        for (int i = 0; i < n - 1; i++) {       // Проходим по массиву столько раз, сколько элементов минус один
            swapped = false;                    // Перед началом прохода сбрасываем флаг

            // Просматриваем оставшиеся элементы массива слева направо
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {     // Если соседние элементы расположены неправильно
                    // Меняем местами элементы
                    int temp = arr[j];
                    arr[j] = arr[j + 1];       
                    arr[j + 1] = temp;
                    
                    swapped = true;           // Поднимаем флаг, значит произошла замена
                }
            }
            
            // Если ни одной замены не произошло, значит массив уже отсортирован
            if (!swapped) break;               // Выходим досрочно из внешнего цикла
        }
    }

    public static void printArray(int[] arr) {
        System.out.print("Отсортированный массив: ");
        for (int value : arr) {
            System.out.print(value + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] array = {64, 34, 25, 12, 22, 11, 99};
        bubbleSort(array);                      // Запускаем процедуру сортировки
        printArray(array);                      // Печать результата
    }
}
Как работает:
•	Внешний цикл регулирует количество полных проходов по массиву.
•	Внутренний цикл сравнивает соседние элементы и меняет их местами, если предыдущий больше последующего.
Сложность: O(n2).

Алгоритм сортировки вставками представляет собой эффективный способ сортировки небольших массивов или частично отсортированных списков. Его основная идея состоит в постепенном расширении отсортированной части списка путем перемещения новых элементов на подходящие места внутри неё.
def insertion_sort(arr):
    # Перебор всех элементов массива, начиная со второго
    for i in range(1, len(arr)):
        key = arr[i]                   # Текущий элемент для вставки
        j = i - 1                      # Индекс предыдущего элемента

        # Перемещаемся назад по отсортированной части массива, пока не найдем подходящее место для вставки current_value
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]       # Смещение большего элемента вправо
            j -= 1                     # Переход к следующему меньшему элементу
        
        arr[j + 1] = key               # Вставка текущего элемента на подходящую позицию

# Тестирование
array = [64, 34, 25, 12, 22, 11]
insertion_sort(array)
print("Отсортированный массив:", array)
Как работает:
•	Берём второй элемент массива и ставим его на правильное место относительно первого элемента.
•	Затем берём третий элемент и вставляем его на нужное место среди предыдущих двух.
•	Повторяем этот процесс для каждого последующего элемента, двигаясь по массиву.
Каждый элемент вставляется в отсортированную часть массива, сдвигая больший элемент вперед, пока не найдёт своё место.
Временная сложность: O(n2) в худшем и среднем случае, O(n) — лучший случай (если массив уже отсортирован).

Алгоритм сортировки слиянием основан на подходе «разделяй и властвуй»: массив делится рекурсивно на две половины, каждая половина сортируется отдельно, а затем обе половинки объединяются обратно в единый отсортированный массив.
#include <iostream>
using namespace std;

// Вспомогательная функция для объединения двух отсортированных частей массива
void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;        // размер левой части
    int n2 = right - mid;           // размер правой части

    // Создание временных массивов для хранения левой и правой частей
    int L[n1], R[n2];

    // Копирование данных в временные массивы
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    // Индексы начальной точки обеих частей и основного массива
    int i = 0, j = 0, k = left;

    // Объединение временно хранящихся частей в основной массив
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {          // Сравниваем элементы и выбираем меньший
            arr[k++] = L[i++];
        } else {
            arr[k++] = R[j++];
        }
    }

    // Добавление оставшихся элементов, если они остались
    while (i < n1)
        arr[k++] = L[i++];
    while (j < n2)
        arr[k++] = R[j++];
}

// Рекурсивная функция сортировки слиянием
void mergeSort(int arr[], int left, int right) {
    if (left < right) {                 // Условие остановки рекурсии
        int mid = left + (right - left) / 2;  // Срединный индекс массива

        // Рекурсивно сортируем левую половину
        mergeSort(arr, left, mid);

        // Рекурсивно сортируем правую половину
        mergeSort(arr, mid + 1, right);

        // Объединяем обе отсортированные половины
        merge(arr, left, mid, right);
    }
}

// Функция печати массива
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++)
        cout << arr[i] << " ";
    cout << endl;
}

// Точка входа программы
int main() {
    int arr[] = {64, 34, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);

    // Вызов функции сортировки
    mergeSort(arr, 0, n - 1);

    // Вывод отсортированного массива
    printArray(arr, n);

    return 0;
}
Как работает:
•	Массив делится пополам рекурсивно до тех пор, пока не останутся отдельные элементы.
•	Отдельные элементы автоматически являются отсортированными.
•	Далее эти маленькие отсортированные куски сливаются вместе в большие отсортированные фрагменты.
•	Итоговый массив получается полностью отсортированным.
Оценка временной сложности: O (nlogn).

Алгоритм сортировки Шелла (Shell Sort) — это улучшенная версия сортировки вставками, использующая идею частичного упорядочивания элементов с большим шагом, а затем уменьшения шага вплоть до единичного интервала, когда массив становится почти отсортированным.
import java.util.Arrays;

class ShellSortExample {
    // Метод для сортировки массива методом Шелла
    public static void shellSort(int[] array) {
        int n = array.length;
        int gap = n / 2; // Первоначальный интервал (шаг) между элементами

        // Пока шаг больше нуля
        while (gap > 0) {
            // Сортируем массив, используя текущий шаг
            for (int i = gap; i < n; i++) {
                int temp = array[i]; // Храним текущий элемент
                int j = i;
                
                // Пересмещаем элементы массива, чтобы освободить место для temp
                while (j >= gap && array[j - gap] > temp) {
                    array[j] = array[j - gap]; // Сдвигаем элемент на gap позиций вправо
                    j -= gap;                  // Идем дальше по массиву
                }
                
                // Вставляем temp на соответствующую позицию
                array[j] = temp;
            }
            
            // Уменьшаем шаг вдвое
            gap /= 2;
        }
    }

    // Метод для вывода массива
    public static void printArray(int[] array) {
        System.out.println(Arrays.toString(array));
    }

    // Главная функция
    public static void main(String[] args) {
        int[] array = {64, 34, 25, 12, 22, 11};
        System.out.println("Исходный массив:");
        printArray(array);

        // Применяем сортировку Шелла
        shellSort(array);

        System.out.println("\nОтсортированный массив:");
        printArray(array);
    }
}
Как работает:
•	Массив сначала сортируется большими шагами, удаляя далеко стоящие элементы друг от друга.
•	Потом шаг уменьшается, снова сортируя элементы с новым расстоянием.
•	Последовательно уменьшают шаг, пока он не достигнет единицы, окончательно упорядочивая массив.
Сложность: O(N3/2) в классическом варианте, при оптимальной стратегии выбора шагов достигает O(N⋅logN).

Быстрая сортировка (Quicksort) — это высокоэффективный алгоритм сортировки, основанный на принципе «разделяй и властвуй». Основная идея заключается в выборе опорного элемента (pivot), разделении массива на две части (элементы меньше pivot и элементы больше pivot), после чего каждая часть рекурсивно сортируется аналогично.
def quicksort(arr):
    """
    Функция реализует быструю сортировку массива arr.
    """
    if len(arr) <= 1:
        return arr  # Базовый случай: пустой массив или массив из одного элемента уже отсортированы
    
    # Выбор опорного элемента (pivot): берем средний элемент массива
    pivot = arr[len(arr) // 2]
    
    # Формируем три списка:
    # 1. Левый список: элементы меньше pivot
    # 2. Средний список: элементы равные pivot
    # 3. Правый список: элементы больше pivot
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    # Рекурсивно сортируем левый и правый списки, затем объединяем их с центральным списком
    return quicksort(left) + middle + quicksort(right)

# Пример использования
if __name__ == "__main__":
    example_array = [3, 6, 8, 10, 1, 2, 1]
    sorted_array = quicksort(example_array)
    print("Отсортированный массив:", sorted_array)
Как работает:
•	Выбираем опорный элемент (pivot).
•	Делим массив на три группы: элементы меньше pivot, равные pivot и больше pivot.
•	Рекурсивно сортируем левую и правую подгруппы.
•	Объединяем отсортированные части, включая группу равных элементов.
Временная сложность:
•	Средняя и лучшая: O(n log n)
•	Худшая: O(n2) (редкий случай)

Пирамидальная сортировка (Heap Sort) — это эффективный алгоритм сортировки, основанный на структуре бинарной кучи. Бинарная куча — это дерево, в котором родительские узлы всегда больше (или меньше) своих дочерних узлов.
#include <iostream>
using namespace std;

// Функции для преобразования подмассива в кучу
void heapify(int arr[], int n, int root) {
    int largest = root;        // Изначально считаем корень максимальным
    int leftChild = 2 * root + 1; // Левый ребенок узла
    int rightChild = 2 * root + 2; // Правый ребенок узла

    // Если левый ребенок существует и больше родителя
    if (leftChild < n && arr[leftChild] > arr[largest])
        largest = leftChild;

    // Если правый ребенок существует и больше родителя
    if (rightChild < n && arr[rightChild] > arr[largest])
        largest = rightChild;

    // Если самый большой элемент не корневой узел, меняем местами и рекурсивно восстанавливаем структуру кучи
    if (largest != root) {
        swap(arr[root], arr[largest]);
        heapify(arr, n, largest); // Рекурсивно исправляем кучу снизу вверх
    }
}

// Основные этапы пирамидальной сортировки
void heapSort(int arr[], int n) {
    // Постройка кучи (преобразование массива в max-кучу)
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i); // Корректируем кучу сверху вниз

    // Извлечение элементов из кучи и построение отсортированного массива
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]); // Максимальный элемент переносим в конец массива
        heapify(arr, i, 0); // Восстанавливаем структуру кучи для оставшихся элементов
    }
}

// Вывод массива
void printArray(int arr[], int n) {
    for (int i = 0; i < n; ++i)
        cout << arr[i] << " ";
    cout << "\n";
}

// Точка входа программы
int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int n = sizeof(arr) / sizeof(arr[0]);

    cout << "Исходный массив:\n";
    printArray(arr, n);

    heapSort(arr, n); // Сортировка массива

    cout << "Отсортированный массив:\n";
    printArray(arr, n);

    return 0;
}
Как работает алгоритм:
1.	Постройка кучи:
•	Преобразовываем массив в структуру binary heap (max-куча), где каждый родительский узел больше своих детей.
2.	Извлечение элементов:
•	Максимальный элемент (корень кучи) переносится в конец массива.
•	Структура кучи обновляется для оставшихся элементов.
•	Повторяем операцию, пока массив не будет отсортирован.
Временная сложность: O(n log n).

Алгоритмы поиска
Последовательный (линейный) поиск — это базовый алгоритм поиска элемента в коллекции, при котором осуществляется просмотр каждого элемента по порядку, пока искомый элемент не будет найден либо не закончится коллекция.
public class LinearSearchExample {
    // Метод для выполнения линейного поиска
    public static int linearSearch(int[] array, int target) {
        // Просматриваем массив поэлементно
        for (int i = 0; i < array.length; i++) {
            // Если текущий элемент равен целевому значению
            if (array[i] == target) {
                return i; // Возврат индекса найденного элемента
            }
        }
        return -1; // Если элемент не найден, возвращаем -1
    }

    // Основная функция для демонстрации работы алгоритма
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50, 60, 70, 80, 90};
        int searchValue = 50;

        // Вызов функции поиска
        int index = linearSearch(numbers, searchValue);

        // Вывод результата
        if (index != -1) {
            System.out.println("Элемент найден на индексе: " + index);
        } else {
            System.out.println("Элемент не найден.");
        }
    }
}
Как работает:
•	Линейный поиск просматривает массив последовательно, начиная с первого элемента.
•	Если текущий элемент совпадает с искомым, немедленно возвращается его индекс.
•	Если искомого элемента нет, пройдя весь массив, вернётся значение -1.
Временная сложность:
•	Лучший случай: O(1) (найден сразу первый элемент),
•	Средний и худший случаи: O(n) (необходимо пройти весь массив).

Бинарный (двоичный) поиск — это быстрый алгоритм поиска элемента в отсортированном массиве. Идея заключается в том, чтобы постоянно делить диапазон поиска пополам, исключая ненужные области массива, основываясь на сравнении центрального элемента с искомым значением.
def binary_search(arr, target):
    low = 0                            # Нижняя граница диапазона поиска
    high = len(arr) - 1                 # Верхняя граница диапазона поиска

    while low <= high:                  # Продолжаем поиск, пока границы не пересекутся
        mid = (low + high) // 2         # Находим середину текущего диапазона
        guess = arr[mid]                # Сравниваемый центральный элемент

        if guess == target:             # Нашли целевой элемент
            return mid                  # Возвращаем индекс элемента
        elif guess > target:            # Центральный элемент больше цели
            high = mid - 1              # Искать в нижней половине
        else:                           # Центральный элемент меньше цели
            low = mid + 1               # Искать в верхней половине

    return None                         # Целевого элемента нет в массиве


# Пример использования
sorted_list = [1, 3, 5, 7, 9, 11, 13, 15]
search_target = 7

result = binary_search(sorted_list, search_target)

if result is not None:
    print(f'Элемент {search_target} найден на позиции {result}')
else:
    print('Элемент не найден')
Как работает алгоритм:
•	На каждом шаге бинарный поиск уменьшает область поиска вдвое, исключая половину массива, где точно нет искомого элемента.
•	Таким образом, с каждым шагом область поиска сужается экспоненциально, что значительно ускоряет поиск по сравнению с простым линейным поиском.
На выходе получается «Элемент 7 найден на позиции 3»
Временная сложность: O(logn)

Поиск по Фибоначчи (Fibonacci Search) — это усовершенствованный вариант бинарного поиска, в котором деление массива на части основано на числах Фибоначчи. Вместо простого разделения массива пополам, алгоритм использует последовательность Фибоначчи для вычисления точек раздела.
public class FibonacciSearch {
    // Генерирует k-е число Фибоначчи
    private static int fibonacci(int k) {
        if (k <= 1) return k;
        return fibonacci(k - 1) + fibonacci(k - 2);
    }

    // Основной метод поиска по Фибоначчи
    public static int fibonacciSearch(int[] arr, int target) {
        int length = arr.length;
        int offset = -1;  // Смещение от начала массива
        int f1 = 0;       // Первое число Фибоначчи
        int f2 = 1;       // Второе число Фибоначчи
        int fNext = f1 + f2;  // Следующее число Фибоначчи

        // Находим самое маленькое число Фибоначчи, которое больше или равно длине массива
        while (fNext < length) {
            f1 = f2;
            f2 = fNext;
            fNext = f1 + f2;
        }

        // Осуществляем поиск по принципу деления массива на части согласно числам Фибоначчи
        while (f2 > 1) {
            int i = Math.min(offset + f1, length - 1);  // Определение средней точки

            if (arr[i] < target) {
                f2 = f1;  // Сужаем поисковую зону
                f1 = fNext - f2;
                fNext = f2;
                offset = i;
            } else if (arr[i] > target) {
                fNext = f1;  // Сужаем поисковую зону
                f1 = fNext - f2;
                f2 = fNext;
            } else {
                return i;  // Элемент найден!
            }
        }

        // Последний этап проверки
        if (f1 == 1 && arr[offset + 1] == target) {
            return offset + 1;
        }

        return -1;  // Элемент не найден
    }

    // Демонстрационная функция
    public static void main(String[] args) {
        int[] data = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100};
        int key = 85;
        int position = fibonacciSearch(data, key);

        if (position != -1) {
            System.out.println("Элемент найден на позиции: " + position);
        } else {
            System.out.println("Элемент не найден");
        }
    }
}
Как работает алгоритм:
•	Сначала определяется наименьшее число Фибоначчи, превышающее или равное длине массива.
•	Используя соотношение чисел Фибоначчи, массив делится на две части: большую и меньшую.
•	Сравнение происходит с элементом, находящимся в точке деления.
•	В зависимости от результата сравнения, поиск продолжается в большей или меньшей части массива.
•	Этот процесс повторяется до тех пор, пока не будет найден нужный элемент или исчерпаны возможные варианты.
На выходе получается «Элемент не найден»
Временная сложность: O(logφn),  где φ ≈ 1.618, золотое сечение.


