# **Аналитическая работа по алгоритмическим структурам сортировки и поиска на языках: C++, Python, Java. (Виговская Катя, УИБО-10-24)**
## 1. Алгоритм сортировки выбором

### Определение:
Сортировка выбором (Selection Sort) — это алгоритм, который последовательно находит минимальные элементы массива и помещает их на правильное место. Таким образом, каждый проход алгоритма гарантирует размещение хотя бы одного элемента на своем месте.

### Анализ:
Алгоритм состоит из двух вложенных циклов:
- Первый цикл выполняется ```N−1``` раз (N — длина массива).
- Второй внутренний цикл также выполняется порядка ```O(N)``` операций на каждом этапе.
##### На выходе получается: "Исходный массив: 64 25 12 22 11 Отсортированный массив: 11 12 22 25 64"

### Временная сложность:
 ```O(n²)```.

### Почему именно так?
Даже если массив уже частично отсортирован, алгоритм всё равно вынужден пройти по всей области слева направо, сравнивая все оставшиеся элементы друг с другом.
Каждый раз нам приходится искать новый минимум, даже если он очевиден визуально.
Это означает, что количество сравнений и перемещений остаётся постоянным независимо от начального состояния массива.

## 2. Алгоритм сортировки пузырьком («Bubble Sort») 

### Определение:
Алгоритм "Bubble Sort" основывается на последовательном сравнении пар соседних элементов и их обмене местами, если порядок нарушен. Процесс повторяется многократно, пока массив не станет упорядоченным.

### Анализ:
- Внешний цикл: Перебирается весь массив за исключением последних уже отсортированных элементов ```(i)```.
- Внутренний цикл: Происходит сравнение каждого текущего элемента ```j``` с последующим элементом ```j+1```. Если текущий элемент больше последующего, они меняются местами.
- Флаг свопа: Используется для оптимизации, если на какой-то итерации не произошло ни одной перестановки, значит массив уже отсортирован, и внешний цикл прерывается раньше.
- Обмен значений: Для изменения позиций используется вспомогательная переменная, в которой временно сохраняется одно из значений.
##### На выходе получилось: "Исходный массив: [64, 34, 25, 12, 22, 11] Отсортированный массив: [11, 12, 22, 25, 34, 64]"
### Временная сложность:
 ```O(n²)```.

### Почему именно так?
- Лучший случай (массив уже отсортирован): ```O(n)```, так как достаточно одного прохода для проверки отсутствия необходимых перестановок.
- Средний и худший случаи (неотсортированные или случайно расположенные элементы): каждое сравнение занимает линейное время относительно длины массива, а число таких сравнений растёт пропорционально квадрату числа элементов.
##### В результате общая асимптотическая сложность равна ```O(n²)``` , что делает алгоритм непригодным для масштабируемых приложений.




